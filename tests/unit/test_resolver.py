"""Tests for DNS resolver detection module."""

from unittest.mock import MagicMock, mock_open, patch
import subprocess

import pytest

from dns_bench.resolver import (
    _deduplicate_resolvers,
    _is_valid_ip,
    _parse_linux_resolvers,
    _parse_macos_resolvers,
    _parse_windows_resolvers,
    get_local_resolvers,
)


class TestIPValidation:
    """Test IP address validation."""

    def test_valid_ipv4(self):
        """Test valid IPv4 addresses."""
        assert _is_valid_ip("8.8.8.8") is True
        assert _is_valid_ip("192.168.1.1") is True
        assert _is_valid_ip("127.0.0.1") is True
        assert _is_valid_ip("1.1.1.1") is True

    def test_valid_ipv6(self):
        """Test valid IPv6 addresses."""
        assert _is_valid_ip("2001:4860:4860::8888") is True
        assert _is_valid_ip("::1") is True
        assert _is_valid_ip("fe80::1") is True

    def test_invalid_ip(self):
        """Test invalid IP addresses."""
        assert _is_valid_ip("999.999.999.999") is False
        assert _is_valid_ip("not-an-ip") is False
        assert _is_valid_ip("") is False
        assert _is_valid_ip("192.168.1") is False
        assert _is_valid_ip("192.168.1.1.1") is False


class TestLinuxResolvers:
    """Test Linux resolver detection."""

    def test_parse_linux_resolvers_success(self):
        """Test successful parsing of /etc/resolv.conf."""
        resolv_conf_content = """# Generated by NetworkManager
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 2001:4860:4860::8888
search example.com
"""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", mock_open(read_data=resolv_conf_content)):
                resolvers = _parse_linux_resolvers()
                assert "8.8.8.8" in resolvers
                assert "8.8.4.4" in resolvers
                assert "2001:4860:4860::8888" in resolvers
                assert len(resolvers) == 3

    def test_parse_linux_resolvers_empty_file(self):
        """Test parsing empty /etc/resolv.conf."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", mock_open(read_data="")):
                resolvers = _parse_linux_resolvers()
                assert resolvers == []

    def test_parse_linux_resolvers_file_not_exists(self):
        """Test when /etc/resolv.conf does not exist."""
        with patch("pathlib.Path.exists", return_value=False):
            resolvers = _parse_linux_resolvers()
            assert resolvers == []

    def test_parse_linux_resolvers_permission_error(self):
        """Test when permission denied on /etc/resolv.conf."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", side_effect=PermissionError):
                resolvers = _parse_linux_resolvers()
                assert resolvers == []

    def test_parse_linux_resolvers_with_comments(self):
        """Test parsing with comments and invalid entries."""
        resolv_conf_content = """# This is a comment
nameserver 1.1.1.1
# nameserver 2.2.2.2 (commented out)
nameserver invalid-ip
nameserver 8.8.8.8
"""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", mock_open(read_data=resolv_conf_content)):
                resolvers = _parse_linux_resolvers()
                assert "1.1.1.1" in resolvers
                assert "8.8.8.8" in resolvers
                assert "invalid-ip" not in resolvers
                assert len(resolvers) == 2


class TestMacOSResolvers:
    """Test macOS resolver detection."""

    def test_parse_macos_resolvers_success(self):
        """Test successful parsing of scutil --dns output."""
        scutil_output = """DNS configuration

resolver #1
  nameserver[0] : 8.8.8.8
  nameserver[1] : 8.8.4.4
  flags    : Request A records, Request AAAA records
  reach    : 0x00000002 (Reachable)

resolver #2
  domain   : local
  options  : mdns
  timeout  : 5
  flags    : Request A records
  reach    : 0x00000000 (Not Reachable)
  order    : 300000

resolver #3
  nameserver[0] : 2001:4860:4860::8888
  flags    : Request A records, Request AAAA records
"""
        mock_result = MagicMock()
        mock_result.returncode = 0
        mock_result.stdout = scutil_output

        with patch("subprocess.run", return_value=mock_result):
            resolvers = _parse_macos_resolvers()
            assert "8.8.8.8" in resolvers
            assert "8.8.4.4" in resolvers
            assert "2001:4860:4860::8888" in resolvers

    def test_parse_macos_resolvers_command_not_found(self):
        """Test when scutil command is not found."""
        with patch("subprocess.run", side_effect=FileNotFoundError):
            resolvers = _parse_macos_resolvers()
            assert resolvers == []

    def test_parse_macos_resolvers_timeout(self):
        """Test when scutil command times out."""
        with patch("subprocess.run", side_effect=subprocess.TimeoutExpired("scutil", 5)):
            resolvers = _parse_macos_resolvers()
            assert resolvers == []

    def test_parse_macos_resolvers_command_fails(self):
        """Test when scutil command returns non-zero exit code."""
        mock_result = MagicMock()
        mock_result.returncode = 1
        mock_result.stdout = ""

        with patch("subprocess.run", return_value=mock_result):
            resolvers = _parse_macos_resolvers()
            assert resolvers == []


class TestWindowsResolvers:
    """Test Windows resolver detection."""

    def test_parse_windows_resolvers_success(self):
        """Test successful parsing of ipconfig /all output."""
        ipconfig_output = """Windows IP Configuration

   Host Name . . . . . . . . . . . . : DESKTOP-TEST
   Primary Dns Suffix  . . . . . . . :
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Intel Network Adapter
   Physical Address. . . . . . . . . : 00-11-22-33-44-55
   DHCP Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes
   IPv4 Address. . . . . . . . . . . : 192.168.1.100
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
   DHCP Server . . . . . . . . . . . : 192.168.1.1
   DNS Servers . . . . . . . . . . . : 8.8.8.8
                                       8.8.4.4
"""
        mock_result = MagicMock()
        mock_result.returncode = 0
        mock_result.stdout = ipconfig_output

        with patch("subprocess.run", return_value=mock_result):
            resolvers = _parse_windows_resolvers()
            assert "8.8.8.8" in resolvers

    def test_parse_windows_resolvers_command_not_found(self):
        """Test when ipconfig command is not found."""
        with patch("subprocess.run", side_effect=FileNotFoundError):
            resolvers = _parse_windows_resolvers()
            assert resolvers == []

    def test_parse_windows_resolvers_timeout(self):
        """Test when ipconfig command times out."""
        with patch("subprocess.run", side_effect=subprocess.TimeoutExpired("ipconfig", 5)):
            resolvers = _parse_windows_resolvers()
            assert resolvers == []

    def test_parse_windows_resolvers_command_fails(self):
        """Test when ipconfig command returns non-zero exit code."""
        mock_result = MagicMock()
        mock_result.returncode = 1
        mock_result.stdout = ""

        with patch("subprocess.run", return_value=mock_result):
            resolvers = _parse_windows_resolvers()
            assert resolvers == []


class TestDeduplication:
    """Test resolver deduplication."""

    def test_deduplicate_resolvers_with_duplicates(self):
        """Test deduplication with duplicate IPs."""
        resolvers = ["8.8.8.8", "1.1.1.1", "8.8.8.8", "1.1.1.1", "8.8.4.4"]
        deduplicated = _deduplicate_resolvers(resolvers)
        assert deduplicated == ["8.8.8.8", "1.1.1.1", "8.8.4.4"]

    def test_deduplicate_resolvers_no_duplicates(self):
        """Test deduplication with no duplicates."""
        resolvers = ["8.8.8.8", "1.1.1.1", "8.8.4.4"]
        deduplicated = _deduplicate_resolvers(resolvers)
        assert deduplicated == ["8.8.8.8", "1.1.1.1", "8.8.4.4"]

    def test_deduplicate_resolvers_empty(self):
        """Test deduplication with empty list."""
        resolvers = []
        deduplicated = _deduplicate_resolvers(resolvers)
        assert deduplicated == []

    def test_deduplicate_resolvers_preserves_order(self):
        """Test that deduplication preserves original order."""
        resolvers = ["3.3.3.3", "1.1.1.1", "2.2.2.2", "1.1.1.1"]
        deduplicated = _deduplicate_resolvers(resolvers)
        assert deduplicated == ["3.3.3.3", "1.1.1.1", "2.2.2.2"]


class TestGetLocalResolvers:
    """Test main get_local_resolvers function."""

    def test_get_local_resolvers_linux(self):
        """Test get_local_resolvers on Linux."""
        resolv_conf_content = """nameserver 8.8.8.8
nameserver 8.8.4.4
"""
        with patch("platform.system", return_value="Linux"):
            with patch("pathlib.Path.exists", return_value=True):
                with patch("builtins.open", mock_open(read_data=resolv_conf_content)):
                    resolvers = get_local_resolvers()
                    assert "8.8.8.8" in resolvers
                    assert "8.8.4.4" in resolvers

    def test_get_local_resolvers_darwin(self):
        """Test get_local_resolvers on macOS."""
        scutil_output = """resolver #1
  nameserver[0] : 1.1.1.1
"""
        mock_result = MagicMock()
        mock_result.returncode = 0
        mock_result.stdout = scutil_output

        with patch("platform.system", return_value="Darwin"):
            with patch("subprocess.run", return_value=mock_result):
                resolvers = get_local_resolvers()
                assert "1.1.1.1" in resolvers

    def test_get_local_resolvers_windows(self):
        """Test get_local_resolvers on Windows."""
        ipconfig_output = "DNS Servers . . . . . . . . . . . : 8.8.8.8"
        mock_result = MagicMock()
        mock_result.returncode = 0
        mock_result.stdout = ipconfig_output

        with patch("platform.system", return_value="Windows"):
            with patch("subprocess.run", return_value=mock_result):
                resolvers = get_local_resolvers()
                assert "8.8.8.8" in resolvers

    def test_get_local_resolvers_fallback(self):
        """Test fallback to 127.0.0.1 when detection fails."""
        with patch("platform.system", return_value="Linux"):
            with patch("pathlib.Path.exists", return_value=False):
                resolvers = get_local_resolvers()
                assert resolvers == ["127.0.0.1"]

    def test_get_local_resolvers_unsupported_os(self):
        """Test fallback on unsupported OS."""
        with patch("platform.system", return_value="UnknownOS"):
            resolvers = get_local_resolvers()
            assert resolvers == ["127.0.0.1"]

    def test_get_local_resolvers_exception_handling(self):
        """Test that exceptions are caught and fallback is returned."""
        with patch("platform.system", side_effect=Exception("Unexpected error")):
            resolvers = get_local_resolvers()
            assert resolvers == ["127.0.0.1"]

    def test_get_local_resolvers_deduplicates(self):
        """Test that get_local_resolvers deduplicates results."""
        resolv_conf_content = """nameserver 8.8.8.8
nameserver 8.8.8.8
nameserver 1.1.1.1
"""
        with patch("platform.system", return_value="Linux"):
            with patch("pathlib.Path.exists", return_value=True):
                with patch("builtins.open", mock_open(read_data=resolv_conf_content)):
                    resolvers = get_local_resolvers()
                    assert resolvers == ["8.8.8.8", "1.1.1.1"]

    def test_get_local_resolvers_returns_list(self):
        """Test that get_local_resolvers always returns a list."""
        with patch("platform.system", return_value="Linux"):
            with patch("pathlib.Path.exists", return_value=False):
                resolvers = get_local_resolvers()
                assert isinstance(resolvers, list)
                assert len(resolvers) > 0
